// When the user clicks on the search box, we want to toggle the search dropdown
function displayToggleSearch(e) {
  e.preventDefault();
  e.stopPropagation();

  closeDropdownSearch(e);
  
  if (idx === null) {
    console.log("Building search index...");
    prepareIdxAndDocMap();
    console.log("Search index built.");
  }
  const dropdown = document.querySelector("#search-dropdown-content");
  if (dropdown) {
    if (!dropdown.classList.contains("show")) {
      dropdown.classList.add("show");
    }
    document.addEventListener("click", closeDropdownSearch);
    document.addEventListener("keydown", searchOnKeyDown);
    document.addEventListener("keyup", searchOnKeyUp);
  }
}

//We want to prepare the index only after clicking the search bar
var idx = null
const docMap = new Map()

function prepareIdxAndDocMap() {
  const docs = [  
    {
      "title": "ADT (Algebraic Data Types)",
      "url": "/circe/codecs/adt.html",
      "content": "ADTs encoding and decoding The most straightforward way to encode / decode ADTs is by using generic derivation for the case classes but explicitly defined instances for the ADT type. Consider the following ADT: sealed trait Event case class Foo(i: Int) extends Event case class Bar(s: String) extends Event case class Baz(c: Char) extends Event case class Qux(values: List[String]) extends Event And the encoder / decoder instances: import cats.syntax.functor._ import io.circe.{ Decoder, Encoder }, io.circe.generic.auto._ import io.circe.syntax._ object GenericDerivation { implicit val encodeEvent: Encoder[Event] = Encoder.instance { case foo @ Foo(_) =&gt; foo.asJson case bar @ Bar(_) =&gt; bar.asJson case baz @ Baz(_) =&gt; baz.asJson case qux @ Qux(_) =&gt; qux.asJson } implicit val decodeEvent: Decoder[Event] = List[Decoder[Event]]( Decoder[Foo].widen, Decoder[Bar].widen, Decoder[Baz].widen, Decoder[Qux].widen ).reduceLeft(_ or _) } Note that we have to call widen (which is provided by Cats’s Functor syntax, which we bring into scope with the first import) on the decoders because the Decoder type class is not covariant. The invariance of circe’s type classes is a matter of some controversy (Argonaut for example has gone from invariant to covariant and back), but it has enough benefits that it’s unlikely to change, which means we need workarounds like this occasionally. It’s also worth noting that our explicit Encoder and Decoder instances will take precedence over the generically-derived instances we would otherwise get from the io.circe.generic.auto._ import (see slides from Travis Brown’s talk here for some discussion of how this prioritization works). We can use these instances like this: import GenericDerivation._ import io.circe.parser.decode decode[Event](\"\"\"{ \"i\": 1000 }\"\"\") // res0: Either[io.circe.Error, Event] = Right(Foo(1000)) (Foo(100): Event).asJson.noSpaces // res1: String = \"{\\\"i\\\":100}\" This works, and if you need to be able to specify the order that the ADT constructors are tried, it’s currently the best solution. Having to enumerate the constructors like this is obviously not ideal, though, even if we get the case class instances for free. A more generic solution As discussed on Gitter, we can avoid the fuss of writing out all the cases by using the circe-shapes module: // To suppress previously imported inplicit codecs. import GenericDerivation.{ decodeEvent =&gt; _, encodeEvent =&gt; _ } object ShapesDerivation { import io.circe.shapes import shapeless.{ Coproduct, Generic } implicit def encodeAdtNoDiscr[A, Repr &lt;: Coproduct](implicit gen: Generic.Aux[A, Repr], encodeRepr: Encoder[Repr] ): Encoder[A] = encodeRepr.contramap(gen.to) implicit def decodeAdtNoDiscr[A, Repr &lt;: Coproduct](implicit gen: Generic.Aux[A, Repr], decodeRepr: Decoder[Repr] ): Decoder[A] = decodeRepr.map(gen.from) } And then: import ShapesDerivation._ import io.circe.parser.decode, io.circe.syntax._ decode[Event](\"\"\"{ \"i\": 1000 }\"\"\") // res2: Either[io.circe.Error, Event] = Right(Foo(1000)) (Foo(100): Event).asJson.noSpaces // res3: String = \"{\\\"i\\\":100}\" This will work for any ADT anywhere that encodeAdtNoDiscr and decodeAdtNoDiscr are in scope. If we wanted it to be more limited, we could replace the generic A with our ADT types in those definitions, or we could make the definitions non-implicit and define implicit instances explicitly for the ADTs we want encoded this way. The main drawback of this approach (apart from the extra circe-shapes dependency) is that the constructors will be tried in alphabetical order, which may not be what we want if we have ambiguous case classes (where the member names and types are the same). The future The generic-extras module provides a little more configurability in this respect. We can write the following, for example: import io.circe.generic.extras.auto._ import io.circe.generic.extras.Configuration implicit val genDevConfig: Configuration = Configuration.default.withDiscriminator(\"what_am_i\") And then: import io.circe.parser.decode, io.circe.syntax._ (Foo(100): Event).asJson.noSpaces // res4: String = \"{\\\"i\\\":100}\" decode[Event](\"\"\"{ \"i\": 1000, \"what_am_i\": \"Foo\" }\"\"\") // res5: Either[io.circe.Error, Event] = Right(Foo(1000)) Instead of a wrapper object in the JSON we have an extra field that indicates the constructor. This isn’t the default behavior since it has some weird corner cases (e.g. if one of our case classes had a member named what_am_i), but in many cases it’s reasonable and it’s been supported in generic-extras since that module was introduced. Notes This still doesn’t get us exactly what we want, but it’s closer than the default behavior. It’s also been considered to change withDiscriminator to take an Option[String] instead of a String, with None indicating that we don’t want an extra field indicating the constructor, giving us the same behavior as our circe-shapes instances in the previous section, but haven’t been implemented so far."
    } ,    
    {
      "title": "Automatic derivation",
      "url": "/circe/codecs/auto-derivation.html",
      "content": "Automatic Derivation It is also possible to derive Encoders and Decoders for many types with no boilerplate at all. Circe uses shapeless to automatically derive the necessary type class instances: import io.circe.generic.auto._, io.circe.syntax._ case class Person(name: String) case class Greeting(salutation: String, person: Person, exclamationMarks: Int) Greeting(\"Hey\", Person(\"Chris\"), 3).asJson // res0: io.circe.Json = JObject( // object[salutation -&gt; \"Hey\",person -&gt; { // \"name\" : \"Chris\" // },exclamationMarks -&gt; 3] // )"
    } ,    
    {
      "title": "Encoding and decoding",
      "url": "/circe/codec.html",
      "content": "Encoding and decoding circe uses Encoder and Decoder type classes for encoding and decoding. An Encoder[A] instance provides a function that will convert any A to a Json, and a Decoder[A] takes a Json value to either an exception or an A. circe provides implicit instances of these type classes for many types from the Scala standard library, including Int, String, and others. It also provides instances for List[A], Option[A], and other generic types, but only if A has an Encoder instance. Encoding data to Json can be done using the .asJson syntax: import io.circe.syntax._ val intsJson = List(1, 2, 3).asJson // intsJson: io.circe.Json = JArray( // Vector(JNumber(JsonLong(1L)), JNumber(JsonLong(2L)), JNumber(JsonLong(3L))) // ) Use the .as syntax for decoding data from Json: intsJson.as[List[Int]] // res0: io.circe.Decoder.Result[List[Int]] = Right(List(1, 2, 3)) The decode function from the included [parser] module can be used to directly decode a JSON String: import io.circe.parser.decode decode[List[Int]](\"[1, 2, 3]\") // res1: Either[io.circe.Error, List[Int]] = Right(List(1, 2, 3))"
    } ,      
    {
      "title": "Traversing and modifying JSON",
      "url": "/circe/cursors.html",
      "content": "Traversing and modifying JSON Working with JSON in circe usually involves using a cursor. Cursors are used both for extracting data and for performing modification. Suppose we have the following JSON document: import cats.syntax.either._ import io.circe._, io.circe.parser._ val json: String = \"\"\" { \"id\": \"c730433b-082c-4984-9d66-855c243266f0\", \"name\": \"Foo\", \"counts\": [1, 2, 3], \"values\": { \"bar\": true, \"baz\": 100.001, \"qux\": [\"a\", \"b\"] } } \"\"\" val doc: Json = parse(json).getOrElse(Json.Null) Extracting data In order to traverse the document we need to create an HCursor with the focus at the document’s root: val cursor: HCursor = doc.hcursor We can then use various operations to move the focus of the cursor around the document and extract data from it: val baz: Decoder.Result[Double] = cursor.downField(\"values\").downField(\"baz\").as[Double] // baz: Decoder.Result[Double] = Right(100.001) // You can also use `get[A](key)` as shorthand for `downField(key).as[A]` val baz2: Decoder.Result[Double] = cursor.downField(\"values\").get[Double](\"baz\") // baz2: Decoder.Result[Double] = Right(100.001) val secondQux: Decoder.Result[String] = cursor.downField(\"values\").downField(\"qux\").downArray.as[String] // secondQux: Decoder.Result[String] = Right(\"a\") Transforming data We can also use a cursor to modify JSON. val reversedNameCursor: ACursor = cursor.downField(\"name\").withFocus(_.mapString(_.reverse)) We can then return to the root of the document and return its value with top: val reversedName: Option[Json] = reversedNameCursor.top // reversedName: Option[Json] = Some( // JObject( // object[id -&gt; \"c730433b-082c-4984-9d66-855c243266f0\",name -&gt; \"ooF\",counts -&gt; [ // 1, // 2, // 3 // ],values -&gt; { // \"bar\" : true, // \"baz\" : 100.001, // \"qux\" : [ // \"a\", // \"b\" // ] // }] // ) // ) The result contains the original document with the \"name\" field reversed. Note that Json is immutable, so the original document is left unchanged. Cursors circe has three slightly different cursor implementations: Cursor provides functionality for moving around a tree and making modifications HCursor tracks the history of operations performed. This can be used to provide useful error messages when something goes wrong. ACursor also tracks history, but represents the possibility of failure (e.g. calling downField on a field that doesn’t exist) Optics Optics are an alternative way to traverse JSON documents. See the Optics page for more details."
    } ,    
    {
      "title": "Custom codecs",
      "url": "/circe/codecs/custom-codecs.html",
      "content": "Custom encoders/decoders If you want to write your own codec instead of using automatic or semi-automatic derivation, you can do so in a couple of ways. Firstly, you can write a new Encoder[A] and Decoder[A] from scratch: import io.circe.{ Decoder, Encoder, HCursor, Json } class Thing(val foo: String, val bar: Int) implicit val encodeFoo: Encoder[Thing] = new Encoder[Thing] { final def apply(a: Thing): Json = Json.obj( (\"foo\", Json.fromString(a.foo)), (\"bar\", Json.fromInt(a.bar)) ) } // encodeFoo: Encoder[Thing] = repl.MdocSession$App$$anon$1@3b310e4a implicit val decodeFoo: Decoder[Thing] = new Decoder[Thing] { final def apply(c: HCursor): Decoder.Result[Thing] = for { foo &lt;- c.downField(\"foo\").as[String] bar &lt;- c.downField(\"bar\").as[Int] } yield { new Thing(foo, bar) } } // decodeFoo: Decoder[Thing] = repl.MdocSession$App$$anon$2@7c0d8f8c But in many cases you might find it more convenient to piggyback on top of the decoders that are already available. For example, a codec for java.time.Instant might look like this: import io.circe.{ Decoder, Encoder } import java.time.Instant import scala.util.Try implicit val encodeInstant: Encoder[Instant] = Encoder.encodeString.contramap[Instant](_.toString) // encodeInstant: Encoder[Instant] = io.circe.Encoder$$anon$1@4a00aa43 implicit val decodeInstant: Decoder[Instant] = Decoder.decodeString.emapTry { str =&gt; Try(Instant.parse(str)) } // decodeInstant: Decoder[Instant] = io.circe.Decoder$$anon$14@5a36dcf7 Older scala versions If you are using custom codecs and an older versions of scala (below 2.12) and you get errors like this value flatMap is not a member of io.circe.Decoder.Result[Option[String]] or value map is not a member of io.circe.Decoder.Result[Option[String]] then you need to use the following import: import cats.syntax.either._ to fix this. Custom key types If you need to encode/decode Map[K, V] where K is not String (or Symbol, Int, Long, etc.), you need to provide a KeyEncoder and/or KeyDecoder for your custom key type. For example: import io.circe._, io.circe.syntax._ case class Foo(value: String) implicit val fooKeyEncoder: KeyEncoder[Foo] = new KeyEncoder[Foo] { override def apply(foo: Foo): String = foo.value } // fooKeyEncoder: KeyEncoder[Foo] = repl.MdocSession$App$$anon$3@6946daa5 val map = Map[Foo, Int]( Foo(\"hello\") -&gt; 123, Foo(\"world\") -&gt; 456 ) // map: Map[Foo, Int] = Map(Foo(\"hello\") -&gt; 123, Foo(\"world\") -&gt; 456) val json = map.asJson // json: Json = JObject(object[hello -&gt; 123,world -&gt; 456]) implicit val fooKeyDecoder: KeyDecoder[Foo] = new KeyDecoder[Foo] { override def apply(key: String): Option[Foo] = Some(Foo(key)) } // fooKeyDecoder: KeyDecoder[Foo] = repl.MdocSession$App$$anon$4@497ba221 json.as[Map[Foo, Int]] // res0: Decoder.Result[Map[Foo, Int]] = Right( // Map(Foo(\"hello\") -&gt; 123, Foo(\"world\") -&gt; 456) // ) Custom key mappings via annotations It’s often necessary to work with keys in your JSON objects that aren’t idiomatic case class member names in Scala. While the standard generic derivation doesn’t support this use case, the experimental circe-generic-extras module does provide two ways to transform your case class member names during encoding and decoding. In many cases the transformation is as simple as going from camel case to snake case, in which case all you need is a custom implicit configuration: import io.circe.generic.extras._, io.circe.syntax._ implicit val config: Configuration = Configuration.default.withSnakeCaseMemberNames // config: Configuration = Configuration( // io.circe.generic.extras.Configuration$$$Lambda$11724/1906985766@62a98c7e, // io.circe.generic.extras.Configuration$$$Lambda$11723/648677548@394fe623, // false, // None, // false // ) @ConfiguredJsonCodec case class User(firstName: String, lastName: String) User(\"Foo\", \"McBar\").asJson // res1: Json = JObject(object[first_name -&gt; \"Foo\",last_name -&gt; \"McBar\"]) In other cases you may need more complex mappings. These can be provided as a function: import io.circe.generic.extras._, io.circe.syntax._ implicit val config: Configuration = Configuration.default.copy( transformMemberNames = { case \"i\" =&gt; \"my-int\" case other =&gt; other } ) // config: Configuration = Configuration( // &lt;function1&gt;, // io.circe.generic.extras.Configuration$$$Lambda$11723/648677548@394fe623, // false, // None, // false // ) @ConfiguredJsonCodec case class Bar(i: Int, s: String) Bar(13, \"Qux\").asJson // res3: io.circe.Json = JObject(object[my-int -&gt; 13,s -&gt; \"Qux\"]) Since this is a common use case, we also support for mapping member names via an annotation: import io.circe.generic.extras._, io.circe.syntax._ implicit val config: Configuration = Configuration.default // config: Configuration = Configuration( // io.circe.generic.extras.Configuration$$$Lambda$11722/1869529582@9dea9e8, // io.circe.generic.extras.Configuration$$$Lambda$11723/648677548@394fe623, // false, // None, // false // ) @ConfiguredJsonCodec case class Bar(@JsonKey(\"my-int\") i: Int, s: String) Bar(13, \"Qux\").asJson // res5: io.circe.Json = JObject(object[my-int -&gt; 13,s -&gt; \"Qux\"]) It’s worth noting that if you don’t want to use the experimental generic-extras module, the completely unmagical forProductN version isn’t really that much of a burden: import io.circe.Encoder, io.circe.syntax._ case class User(firstName: String, lastName: String) case class Bar(i: Int, s: String) implicit val encodeUser: Encoder[User] = Encoder.forProduct2(\"first_name\", \"last_name\")(u =&gt; (u.firstName, u.lastName)) // encodeUser: Encoder[User] = io.circe.ProductEncoders$$anon$2@3089dad6 implicit val encodeBar: Encoder[Bar] = Encoder.forProduct2(\"my-int\", \"s\")(b =&gt; (b.i, b.s)) // encodeBar: Encoder[Bar] = io.circe.ProductEncoders$$anon$2@4253d623 User(\"Foo\", \"McBar\").asJson // res7: io.circe.Json = JObject( // object[first_name -&gt; \"Foo\",last_name -&gt; \"McBar\"] // ) Bar(13, \"Qux\").asJson // res8: io.circe.Json = JObject(object[my-int -&gt; 13,s -&gt; \"Qux\"]) While this version does involve a bit of boilerplate, it only requires circe-core, and may have slightly better runtime performance in some cases."
    } ,    
    {
      "title": "Home",
      "url": "/circe/",
      "content": "circe (pronounced SUR-see, or KEER-kee in classical Greek, or CHEER-chay in Ecclesiastical Latin) is a JSON library for Scala (and Scala.js). circe’s working title was jfc, which stood for “JSON for cats”. The name was changed for a number of reasons. Quick start circe is published to Maven Central and cross-built for Scala 2.12 and 2.13, so you can just add the following to your build: val circeVersion = \"0.14.1\" libraryDependencies ++= Seq( \"io.circe\" %% \"circe-core\", \"io.circe\" %% \"circe-generic\", \"io.circe\" %% \"circe-parser\" ).map(_ % circeVersion) In case of large or deep-nested case classes, there is a chance to get stack overflow during compilation, please refer to known-issues for workaround. If you’re using circe-generic-extra’s @JsonCodec macro annotations, you’ll need to add -Ymacro-annotations to your compiler options on Scala 2.13, or to include the Macro Paradise compiler plugin in your build on earlier Scala versions: addCompilerPlugin( \"org.scalamacros\" % \"paradise\" % \"2.1.1\" cross CrossVersion.full ) Then type sbt console to start a REPL and then paste the following (this will also work from the root directory of this repository): import io.circe._, io.circe.generic.auto._, io.circe.parser._, io.circe.syntax._ sealed trait Foo case class Bar(xs: Vector[String]) extends Foo case class Qux(i: Int, d: Option[Double]) extends Foo val foo: Foo = Qux(13, Some(14.0)) val json = foo.asJson.noSpaces println(json) val decodedFoo = decode[Foo](json) println(decodedFoo) Alternatively you can experiment with Circe directly in your browser by clicking the Run button in the code block and making modifications in the code. No boilerplate, no runtime reflection. Why? Argonaut is a great library. It’s by far the best JSON library for Scala, and the best JSON library on the JVM. If you’re doing anything with JSON in Scala, you should be using Argonaut. circe is a fork of Argonaut with a few important differences. Dependencies and modularity circe depends on cats instead of Scalaz, and the core project has only one dependency (cats-core). Other subprojects bring in dependencies on Jawn (for parsing in the jawn subproject), Shapeless (for automatic codec derivation in generic), but it would be possible to replace the functionality provided by these subprojects with alternative implementations that use other libraries. Parsing circe doesn’t include a JSON parser in the core project, which is focused on the JSON AST, zippers, and codecs. The jawn subproject provides support for parsing JSON via a Jawn facade. Jawn is fast, it offers asynchronous parsing, and best of all it lets us drop a lot of the fussiest code in Argonaut. The circe-jackson project supports using Jackson for both parsing and printing. circe also provides a parser subproject that provides parsing support for Scala.js, with JVM parsing provided by io.circe.jawn and JavaScript parsing from scalajs.js.JSON. See the Parsing page for more details. Lenses circe doesn’t use or provide lenses in the core project. This is related to the first point above, since Monocle has a Scalaz dependency, but we also feel that it simplifies the API. The 0.3.0 release added an experimental optics subproject that provides Monocle lenses. See the Optics page for more details. Codec derivation circe does not use macros or provide any kind of automatic derivation in the core project. Instead of Argonaut’s limited macro-based derivation (which does not support sealed trait hierarchies, for example), circe includes a subproject (generic) that provides generic codec derivation using Shapeless. This subproject is currently a simplified port of argonaut-shapeless that provides fully automatic derivation of instances for case classes and sealed trait hierarchies. It also includes derivation of “incomplete” case class instances (see my recent blog post for details). Note that if you use -Ypartial-unification and auto, incomplete decoders will not work (see #724). See the Encoding and Decoding page for more details. Aliases circe aims to simplify Argonaut’s API by removing all operator aliases. This is largely a matter of personal taste, and may change in the future. Testing I’d like to provide more complete test coverage (in part via Discipline), but it’s early days for this. Performance circe is developed with a focus on performance. See the Performance page for details. License circe is licensed under the Apache License, Version 2.0 (the “License”); you may not use this software except in compliance with the License. Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an “AS IS” BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License."
    } ,    
    {
      "title": "Warnings and known issues",
      "url": "/circe/codecs/known-issues.html",
      "content": "Warnings and known issues Generic derivation may not work as expected when the type definitions that you’re trying to derive instances for are at the same level as the attempted derivation. For example: scala&gt; import io.circe.Decoder, io.circe.generic.auto._ import io.circe.Decoder import io.circe.generic.auto._ scala&gt; sealed trait A; case object B extends A; object X { val d = Decoder[A] } defined trait A defined object B defined object X scala&gt; object X { sealed trait A; case object B extends A; val d = Decoder[A] } &lt;console&gt;:19: error: could not find implicit value for parameter d: io.circe.Decoder[X.A] object X { sealed trait A; case object B extends A; val d = Decoder[A] } This is unfortunately a limitation of the macro API that Shapeless uses to derive the generic representation of the sealed trait. You can manually define these instances, or you can arrange the sealed trait definition so that it is not in the same immediate scope as the attempted derivation (which is typically what you want, anyway). For large or deeply-nested case classes and sealed trait hierarchies, the generic derivation provided by the generic subproject may stack overflow during compilation, which will result in the derived encoders or decoders simply not being found. Increasing the stack size available to the compiler (e.g. with sbt -J-Xss64m if you’re using SBT) will help in many cases, but we have at least one report of a case where it doesn’t. It might be simpler and safer to add .sbtopts file with SBT parameters (-J-Xss64m) in root of project. More generally, the generic derivation provided by the generic subproject works for a wide range of test cases, and is likely to just work for you, but it relies on macros (provided by Shapeless) that rely on compiler functionality that is not always perfectly robust (“SI-7046 is like playing roulette”), and if you’re running into problems, it’s likely that they’re not your fault. Please file an issue here or ask a question on the Gitter channel, and we’ll do our best to figure out whether the problem is something we can fix. When using the io.circe.generic.JsonCodec annotation, the following will not compile: import io.circe.generic.JsonCodec @JsonCodec sealed trait A case class B(b: String) extends A case class C(c: Int) extends A In cases like this it’s necessary to define a companion object for the root type after all of the leaf types: import io.circe.generic.JsonCodec @JsonCodec sealed trait A case class B(b: String) extends A case class C(c: Int) extends A object A See this issue for additional discussion (this workaround may not be necessary in future versions). circe’s representation of numbers is designed not to lose precision during decoding into integral or arbitrary-precision types, but precision may still be lost during parsing. This shouldn’t happen when using Jawn for parsing, but scalajs.js.JSON parses JSON numbers into a floating point representation that may lose precision (even when decoding into a type like BigDecimal; see this issue for an example). knownDirectSubclasses error While using fully automatic derivation, you may have run into an error that looks like this: knownDirectSubclasses of &lt;class&gt; observed before subclass &lt;class&gt; registered This is a known issue (#434, #659) that stems from the way fully automatic derivation relies on Shapeless, which in turn conditionally calls a Scala Reflect named called knownDirectSubclasses. This method has been known to fail depending on how the types that it interacts with are declared in your codebase. Here is a collection workarounds found by other users that you can try: Rename your files/directories so that the files containing types that get encoded/decoded come alphabetically before the files that import io.circe.generic.auto._ and turn values of those types into JSON. If you’ve got a sealed trait (e.g. sealed trait MyEnum) and it has subclasses that are declared in its companion object, try adding a import MyEnum._ statement before any calls that force the materialising of an encoder/decoder. import io.circe.syntax._ import io.circe.generic.auto._ val person = Person(\"hello\", Role.User) import Role._ val asJson = person.asJson Alternatively, if you are OK with losing namespacing for your enum members you can try moving the subclasses out of the parent trait’s companion object and into the same namespace space as the parent trait: // Modify this sealed trait ShirtSize object ShirtSize { case object Small extends ShirtSize case object Medium extends ShirtSize case object Large extends ShirtSize } // into this sealed trait ShirtSizes case object Small extends ShirtSizes case object Medium extends ShirtSizes case object Large extends ShirtSizes Try using Scala 2.11.8, the last known version of Scala that did not exhibit this problem. If none of these workarounds are desirable for your use case, it might be a good idea to try semi-auto derivation instead."
    } ,    
    {
      "title": "Optics",
      "url": "/circe/optics.html",
      "content": "Optics Optics are a powerful tool for traversing and modifying JSON documents. They can reduce boilerplate considerably, especially if you are working with deeply nested JSON. circe provides support for optics by integrating with Monocle. To use them, add a dependency on circe-optics to your build: libraryDependencies += \"io.circe\" %% \"circe-optics\" % circeVersion Note that this will require your project to depend on both Scalaz and cats. Traversing JSON Suppose we have the following JSON document: import io.circe._, io.circe.parser._ val json: Json = parse(\"\"\" { \"order\": { \"customer\": { \"name\": \"Custy McCustomer\", \"contactDetails\": { \"address\": \"1 Fake Street, London, England\", \"phone\": \"0123-456-789\" } }, \"items\": [{ \"id\": 123, \"description\": \"banana\", \"quantity\": 1 }, { \"id\": 456, \"description\": \"apple\", \"quantity\": 2 }], \"total\": 123.45 } } \"\"\").getOrElse(Json.Null) If we wanted to get the customer’s phone number, we could do it using a cursor as follows: val phoneNumFromCursor: Option[String] = json.hcursor. downField(\"order\"). downField(\"customer\"). downField(\"contactDetails\"). get[String](\"phone\"). toOption // phoneNumFromCursor: Option[String] = Some(\"0123-456-789\") This works, but it’s a little verbose. We could rewrite it using optics like this: import io.circe.optics.JsonPath._ val _phoneNum = root.order.customer.contactDetails.phone.string // _phoneNum: monocle.package.Optional[Json, String] = monocle.POptional$$anon$1@46172a43 val phoneNum: Option[String] = _phoneNum.getOption(json) // phoneNum: Option[String] = Some(\"0123-456-789\") Note the difference between cursors and optics. With cursors, we start with a JSON document, get a cursor from it, and then use that cursor to traverse the document. With optics, on the other hand, we first define the traversal we want to make, then apply it to a JSON document. In other words, optics provide a way to separate the description of a JSON traversal from its execution. Consequently we can reuse the same traversal against many different documents, compose traversals together, and so on. Let’s look at a more complex example. This time we want to get the quantities of all the items in the order. Using a cursor it might look like this: val itemsFromCursor: Vector[Json] = json.hcursor. downField(\"order\"). downField(\"items\"). focus. flatMap(_.asArray). getOrElse(Vector.empty) // itemsFromCursor: Vector[Json] = Vector( // JObject(object[id -&gt; 123,description -&gt; \"banana\",quantity -&gt; 1]), // JObject(object[id -&gt; 456,description -&gt; \"apple\",quantity -&gt; 2]) // ) val quantities: Vector[Int] = itemsFromCursor.flatMap(_.hcursor.get[Int](\"quantity\").toOption) // quantities: Vector[Int] = Vector(1, 2) And with optics: val items: List[Int] = root.order.items.each.quantity.int.getAll(json) // items: List[Int] = List(1, 2) Modifying JSON Optics can also be used for making modifications to JSON. Suppose we decide to have a 2-for-1 sale, so we want to double all the quantities in the order. This can be achieved with a small change to the code we wrote for traversal: val doubleQuantities: Json =&gt; Json = root.order.items.each.quantity.int.modify(_ * 2) // doubleQuantities: Json =&gt; Json = monocle.PTraversal$$Lambda$12315/93663477@f1fe551 val modifiedJson = doubleQuantities(json) // modifiedJson: Json = JObject( // object[order -&gt; { // \"customer\" : { // \"name\" : \"Custy McCustomer\", // \"contactDetails\" : { // \"address\" : \"1 Fake Street, London, England\", // \"phone\" : \"0123-456-789\" // } // }, // \"items\" : [ // { // \"id\" : 123, // \"description\" : \"banana\", // \"quantity\" : 2 // }, // { // \"id\" : 456, // \"description\" : \"apple\", // \"quantity\" : 4 // } // ], // \"total\" : 123.45 // }] // ) The result is a copy of the original JSON with only the quantity fields updated. Recursively modifying JSON Sometimes you may need to recursively modify JSON. Let assume you need to transform all numbers into strings in the example JSON: import io.circe.optics.JsonOptics._ import monocle.function.Plated Plated.transform[Json] { j =&gt; j.asNumber match { case Some(n) =&gt; Json.fromString(n.toString) case None =&gt; j } }(json) // res0: Json = JObject( // object[order -&gt; { // \"customer\" : { // \"name\" : \"Custy McCustomer\", // \"contactDetails\" : { // \"address\" : \"1 Fake Street, London, England\", // \"phone\" : \"0123-456-789\" // } // }, // \"items\" : [ // { // \"id\" : \"123\", // \"description\" : \"banana\", // \"quantity\" : \"1\" // }, // { // \"id\" : \"456\", // \"description\" : \"apple\", // \"quantity\" : \"2\" // } // ], // \"total\" : \"123.45\" // }] // ) Dynamic Some of the code above may look quite magical at first glance. How are we calling methods like order, items and customer on circe’s JsonPath class? The answer is that JsonPath relies on a slightly obscure feature of Scala called Dynamic. This means you can call methods that don’t actually exist. When you do so, the selectDynamic method is called, and the name of the method you wanted to call is passed as an argument. Warning The use of Dynamic means that your code is not “typo-safe”. For example, if you fat-finger the previous example: val doubleQuantities: Json =&gt; Json = root.order.itemss.each.quantity.int.modify(_ * 2) // Note the \"itemss\" typo val modifiedJson = doubleQuantities(json) This code will compile just fine, but not do what you expect. Because the JSON document doesn’t have an itemss field, the same document will be returned unmodified."
    } ,    
    {
      "title": "Parsing JSON",
      "url": "/circe/parsing.html",
      "content": "Parsing JSON Circe includes a parsing module, which on the JVM is a wrapper around the Jawn JSON parser and for JavaScript uses the built-in JSON.parse. Parsing is not part of the circe-core module, so you will need to include a dependency on the circe-parser module in your build: libraryDependencies += \"io.circe\" %% \"circe-parser\" % circeVersion Parsing is done as follows. import io.circe._, io.circe.parser._ val rawJson: String = \"\"\" { \"foo\": \"bar\", \"baz\": 123, \"list of stuff\": [ 4, 5, 6 ] } \"\"\" // rawJson: String = \"\"\" // { // \"foo\": \"bar\", // \"baz\": 123, // \"list of stuff\": [ 4, 5, 6 ] // } // \"\"\" val parseResult = parse(rawJson) // parseResult: Either[ParsingFailure, Json] = Right( // JObject( // object[foo -&gt; \"bar\",baz -&gt; 123,list of stuff -&gt; [ // 4, // 5, // 6 // ]] // ) // ) Because parsing might fail, the result is an Either with an io.circe.Error on the left side. In the example above, the input was valid JSON, so the result was a Right containing the corresponding JSON representation. Let’s see what happens when you try to parse invalid JSON: val badJson: String = \"yolo\" // badJson: String = \"yolo\" parse(badJson) // res0: Either[ParsingFailure, Json] = Left( // ParsingFailure( // \"expected json value got 'yolo' (line 1, column 1)\", // ParseException(\"expected json value got 'yolo' (line 1, column 1)\", 0, 1, 1) // ) // ) There are a number of ways to extract the parse result from the Either. For example you could pattern match on it: parse(rawJson) match { case Left(failure) =&gt; println(\"Invalid JSON :(\") case Right(json) =&gt; println(\"Yay, got some JSON!\") } // Yay, got some JSON! Or use getOrElse (an extension method provided by Cats): val json: Json = parse(rawJson).getOrElse(Json.Null) // json: Json = JObject( // object[foo -&gt; \"bar\",baz -&gt; 123,list of stuff -&gt; [ // 4, // 5, // 6 // ]] // ) Warnings and known issues When using the Scala.js version of circe, numerical values like Long may lose precision when decoded. For example decode[Long](\"767946224062369796\") will return Right(767946224062369792L). This is not a limitation of how Scala.js represents scala.Longs nor circe’s decoders for numerical values but due to JSON.parse converting numerical values to JavaScript numbers. If precision is required consider representing numerical values as strings and convert them to their final value via the JSON AST."
    } ,      
    {
      "title": "Performance",
      "url": "/circe/performance.html",
      "content": "Performance circe aims to be more focused on performance. I’m still experimenting with the right balance, but I’m open to using mutability, inheritance, and all kinds of other horrible things under the hood if they make circe faster (the public API does not and will never expose any of this, though). My initial benchmarks suggest this is at least kind of working (higher numbers are better): Benchmark Mode Cnt Score Error Units DecodingBenchmark.decodeFoosC thrpt 40 3711.680 ± 22.766 ops/s DecodingBenchmark.decodeFoosA thrpt 40 1519.045 ± 11.373 ops/s DecodingBenchmark.decodeFoosP thrpt 40 2032.834 ± 27.033 ops/s DecodingBenchmark.decodeFoosPico thrpt 40 2003.106 ± 10.463 ops/s DecodingBenchmark.decodeFoosS thrpt 40 7053.699 ± 35.127 ops/s DecodingBenchmark.decodeIntsC thrpt 40 19101.875 ± 324.123 ops/s DecodingBenchmark.decodeIntsA thrpt 40 8000.093 ± 215.702 ops/s DecodingBenchmark.decodeIntsP thrpt 40 18160.031 ± 68.777 ops/s DecodingBenchmark.decodeIntsPico thrpt 40 11979.085 ± 89.793 ops/s DecodingBenchmark.decodeIntsS thrpt 40 81279.228 ± 1203.751 ops/s EncodingBenchmark.encodeFoosC thrpt 40 7353.158 ± 133.633 ops/s EncodingBenchmark.encodeFoosA thrpt 40 5638.358 ± 30.315 ops/s EncodingBenchmark.encodeFoosP thrpt 40 2324.075 ± 17.868 ops/s EncodingBenchmark.encodeFoosPico thrpt 40 5056.317 ± 45.876 ops/s EncodingBenchmark.encodeFoosS thrpt 40 5307.422 ± 29.666 ops/s EncodingBenchmark.encodeIntsC thrpt 40 117885.093 ± 2151.059 ops/s EncodingBenchmark.encodeIntsA thrpt 40 72986.276 ± 1561.295 ops/s EncodingBenchmark.encodeIntsP thrpt 40 55117.582 ± 650.154 ops/s EncodingBenchmark.encodeIntsPico thrpt 40 31602.757 ± 351.578 ops/s EncodingBenchmark.encodeIntsS thrpt 40 40509.667 ± 560.439 ops/s ParsingBenchmark.parseFoosC thrpt 40 2869.779 ± 61.898 ops/s ParsingBenchmark.parseFoosA thrpt 40 2615.299 ± 25.881 ops/s ParsingBenchmark.parseFoosP thrpt 40 1970.493 ± 90.383 ops/s ParsingBenchmark.parseFoosPico thrpt 40 3113.232 ± 29.081 ops/s ParsingBenchmark.parseFoosS thrpt 40 3725.056 ± 68.794 ops/s ParsingBenchmark.parseIntsC thrpt 40 13062.151 ± 209.713 ops/s ParsingBenchmark.parseIntsA thrpt 40 11066.850 ± 159.308 ops/s ParsingBenchmark.parseIntsP thrpt 40 18980.265 ± 91.351 ops/s ParsingBenchmark.parseIntsPico thrpt 40 15184.314 ± 37.808 ops/s ParsingBenchmark.parseIntsS thrpt 40 15495.935 ± 388.922 ops/s PrintingBenchmark.printFoosC thrpt 40 4090.218 ± 38.804 ops/s PrintingBenchmark.printFoosA thrpt 40 2863.570 ± 19.091 ops/s PrintingBenchmark.printFoosP thrpt 40 9042.816 ± 49.199 ops/s PrintingBenchmark.printFoosPico thrpt 40 4759.601 ± 20.467 ops/s PrintingBenchmark.printFoosS thrpt 40 7297.047 ± 28.168 ops/s PrintingBenchmark.printIntsC thrpt 40 24596.715 ± 66.366 ops/s PrintingBenchmark.printIntsA thrpt 40 15611.121 ± 140.017 ops/s PrintingBenchmark.printIntsP thrpt 40 66283.874 ± 731.534 ops/s PrintingBenchmark.printIntsPico thrpt 40 23703.796 ± 188.186 ops/s PrintingBenchmark.printIntsS thrpt 40 53015.753 ± 462.472 ops/s And allocation rates (lower is better): Benchmark Mode Cnt Score Error Units DecodingBenchmark.decodeFoosC:gc.alloc.rate.norm thrpt 20 1308424.455 ± 0.881 B/op DecodingBenchmark.decodeFoosA:gc.alloc.rate.norm thrpt 20 3779097.640 ± 2.456 B/op DecodingBenchmark.decodeFoosP:gc.alloc.rate.norm thrpt 20 2201336.820 ± 1.588 B/op DecodingBenchmark.decodeFoosPico:gc.alloc.rate.norm thrpt 20 506696.832 ± 1.608 B/op DecodingBenchmark.decodeFoosS:gc.alloc.rate.norm thrpt 20 273184.238 ± 0.458 B/op DecodingBenchmark.decodeIntsC:gc.alloc.rate.norm thrpt 20 291360.090 ± 0.174 B/op DecodingBenchmark.decodeIntsA:gc.alloc.rate.norm thrpt 20 655448.200 ± 0.387 B/op DecodingBenchmark.decodeIntsP:gc.alloc.rate.norm thrpt 20 369144.097 ± 0.189 B/op DecodingBenchmark.decodeIntsPico:gc.alloc.rate.norm thrpt 20 235400.144 ± 0.280 B/op DecodingBenchmark.decodeIntsS:gc.alloc.rate.norm thrpt 20 38136.021 ± 0.041 B/op EncodingBenchmark.encodeFoosC:gc.alloc.rate.norm thrpt 20 395272.225 ± 0.433 B/op EncodingBenchmark.encodeFoosA:gc.alloc.rate.norm thrpt 20 521136.306 ± 0.595 B/op EncodingBenchmark.encodeFoosP:gc.alloc.rate.norm thrpt 20 1367800.719 ± 7.263 B/op EncodingBenchmark.encodeFoosPico:gc.alloc.rate.norm thrpt 20 281992.346 ± 0.674 B/op EncodingBenchmark.encodeFoosS:gc.alloc.rate.norm thrpt 20 377856.318 ± 0.615 B/op EncodingBenchmark.encodeIntsC:gc.alloc.rate.norm thrpt 20 64160.016 ± 7.129 B/op EncodingBenchmark.encodeIntsA:gc.alloc.rate.norm thrpt 20 80152.023 ± 0.044 B/op EncodingBenchmark.encodeIntsP:gc.alloc.rate.norm thrpt 20 71352.030 ± 0.058 B/op EncodingBenchmark.encodeIntsPico:gc.alloc.rate.norm thrpt 20 58992.057 ± 0.115 B/op EncodingBenchmark.encodeIntsS:gc.alloc.rate.norm thrpt 20 76176.042 ± 0.081 B/op ParsingBenchmark.parseFoosC:gc.alloc.rate.norm thrpt 20 765800.586 ± 1.133 B/op ParsingBenchmark.parseFoosA:gc.alloc.rate.norm thrpt 20 1488760.635 ± 1.228 B/op ParsingBenchmark.parseFoosP:gc.alloc.rate.norm thrpt 20 987720.805 ± 1.551 B/op ParsingBenchmark.parseFoosPico:gc.alloc.rate.norm thrpt 20 639464.525 ± 1.014 B/op ParsingBenchmark.parseFoosS:gc.alloc.rate.norm thrpt 20 252256.440 ± 0.838 B/op ParsingBenchmark.parseIntsC:gc.alloc.rate.norm thrpt 20 121272.129 ± 0.250 B/op ParsingBenchmark.parseIntsA:gc.alloc.rate.norm thrpt 20 310280.151 ± 0.289 B/op ParsingBenchmark.parseIntsP:gc.alloc.rate.norm thrpt 20 216448.089 ± 0.171 B/op ParsingBenchmark.parseIntsPico:gc.alloc.rate.norm thrpt 20 141808.118 ± 0.239 B/op ParsingBenchmark.parseIntsS:gc.alloc.rate.norm thrpt 20 109000.117 ± 0.229 B/op PrintingBenchmark.printFoosC:gc.alloc.rate.norm thrpt 20 425240.419 ± 0.810 B/op PrintingBenchmark.printFoosA:gc.alloc.rate.norm thrpt 20 621288.585 ± 1069.068 B/op PrintingBenchmark.printFoosP:gc.alloc.rate.norm thrpt 20 351360.184 ± 0.356 B/op PrintingBenchmark.printFoosPico:gc.alloc.rate.norm thrpt 20 431268.348 ± 1058.404 B/op PrintingBenchmark.printFoosS:gc.alloc.rate.norm thrpt 20 372992.228 ± 0.442 B/op PrintingBenchmark.printIntsC:gc.alloc.rate.norm thrpt 20 74464.067 ± 7.127 B/op PrintingBenchmark.printIntsA:gc.alloc.rate.norm thrpt 20 239712.107 ± 0.206 B/op PrintingBenchmark.printIntsP:gc.alloc.rate.norm thrpt 20 24144.025 ± 0.048 B/op PrintingBenchmark.printIntsPico:gc.alloc.rate.norm thrpt 20 95472.072 ± 0.140 B/op PrintingBenchmark.printIntsS:gc.alloc.rate.norm thrpt 20 24048.032 ± 0.062 B/op The Foos benchmarks work with a map containing case class values, and the Ints ones are an array of integers. C suffixes indicate circe’s throughput, A is for Argonaut, P is for play-json, Pico is for picopickle, and S is for spray-json. Note that spray-json’s approach to failure handling is different from the approaches of the other libraries listed here (it simply throws exceptions), and this difference should be taken into account when comparing its results with the others."
    } ,      
    {
      "title": "Semi-automatic derivation",
      "url": "/circe/codecs/semiauto-derivation.html",
      "content": "Semi-automatic Derivation Sometimes it’s convenient to have an Encoder or Decoder defined in your code, and semi-automatic derivation can help. You’d write: import io.circe._, io.circe.generic.semiauto._ case class Foo(a: Int, b: String, c: Boolean) implicit val fooDecoder: Decoder[Foo] = deriveDecoder[Foo] implicit val fooEncoder: Encoder[Foo] = deriveEncoder[Foo] Or simply: import io.circe._, io.circe.generic.semiauto._ case class Foo(a: Int, b: String, c: Boolean) implicit val fooDecoder: Decoder[Foo] = deriveDecoder implicit val fooEncoder: Encoder[Foo] = deriveEncoder @JsonCodec The circe-generic project includes a @JsonCodec annotation that simplifies the use of semi-automatic generic derivation: import io.circe.generic.JsonCodec, io.circe.syntax._ @JsonCodec case class Bar(i: Int, s: String) Bar(13, \"Qux\").asJson // res1: Json = JObject(object[i -&gt; 13,s -&gt; \"Qux\"]) This works with both case classes and sealed trait hierarchies. NOTE: You will need to use the -Ymacro-annotations flag to use annotation macros like @JsonCodec. (If you’re using Scala 2.10.x to Scala 2.12.x you will need the Macro Paradise plugin instead). forProductN helper methods It’s also possible to construct encoders and decoders for case class-like types in a relatively boilerplate-free way without generic derivation: import io.circe.{ Decoder, Encoder } case class User(id: Long, firstName: String, lastName: String) implicit val decodeUser: Decoder[User] = Decoder.forProduct3(\"id\", \"first_name\", \"last_name\")(User.apply) // decodeUser: Decoder[User] = io.circe.ProductDecoders$$anon$3@5e13c99e implicit val encodeUser: Encoder[User] = Encoder.forProduct3(\"id\", \"first_name\", \"last_name\")(u =&gt; (u.id, u.firstName, u.lastName) ) // encodeUser: Encoder[User] = io.circe.ProductEncoders$$anon$3@7d5afaad It’s not as clean or as maintainable as generic derivation, but it’s less magical, it requires nothing but circe-core, and if you need a custom name mapping it’s currently the best solution (although 0.6.0 introduces experimental configurable generic derivation in the circe-generic-extras module)."
    } ,    
    {
      "title": "Codec testing",
      "url": "/circe/codecs/testing.html",
      "content": "Codec testing Suppose you have the following Person case class and hand-written encoders and decoders. In this case, your decoder includes a typo, \"mame\" instead of \"name\". import io.circe._ import io.circe.syntax._ case class Person(name: String) object Person { implicit val encPerson: Encoder[Person] = Encoder.forProduct1(\"name\")(_.name) implicit val decPerson: Decoder[Person] = Decoder.forProduct1(\"mame\")(Person.apply _) } If you try to encode then decode a Person, you won’t be succecssful: Person(\"James\").asJson.as[Person] // res0: Decoder.Result[Person] = Left( // DecodingFailure(Attempt to decode value on failed cursor, List(DownField(mame))) // ) This process is an example of a round trip. We can think about this round trip at two different levels. Thinking about it for the particular case class Person, we can say that any Person should round trip. This is a property we expect about the Person case class. However, this is a common expectation for anything that has both an Encoder and Decoder. In that sense, round tripping is a property we expect about anything with a Codec. When we have expectations about all things that implement some typeclass, we have a law. Codec laws To check Codec laws for your custom types, they’ll need two implicits in scope – Arbitrary and Eq. import cats.Eq import io.circe.testing.ArbitraryInstances import org.scalacheck.{Arbitrary, Gen} object Implicits extends ArbitraryInstances { implicit val eqPerson: Eq[Person] = Eq.fromUniversalEquals implicit val arbPerson: Arbitrary[Person] = Arbitrary { Gen.listOf(Gen.alphaChar) map { chars =&gt; Person(chars.mkString(\"\")) } } } The presence of those implicit values and an import from the circe-testing module will allow you to create a CodecTests[Person]: import io.circe.testing.CodecTests val personCodecTests = CodecTests[Person] // personCodecTests: CodecTests[Person] = io.circe.testing.CodecTests$$anon$2@5623adb0 CodecTests[T] expose two “rule sets” that can be used with Discipline. The less restrictive set is unserializableCodec. import Implicits._ personCodecTests.unserializableCodec // res1: personCodecTests.RuleSet = org.typelevel.discipline.Laws$DefaultRuleSet@2a041f42 It checks whether the Codec for your type successfully round trips through json serialization and deserialization and whether your decoder satisfies consistent error accumulation. The more restrictive set is codec: personCodecTests.codec // res2: personCodecTests.RuleSet = org.typelevel.discipline.Laws$DefaultRuleSet@26de904a It checks the laws from unserializableCodec and ensures that your encoder and decoder can be serialized to and from Java byte array streams. It is generally a good idea to use the stronger laws from .codec, and you definitely should use them if you’re in a setting where the JVM has to ship a lot of data around, for example in a Spark application. However, if you’re not in a distributed setting and the serializability laws are getting in your way, it’s fine to skip them with the unserializableCodec."
    }    
  ];

  idx = lunr(function () {
    this.ref("title");
    this.field("content");

    docs.forEach(function (doc) {
      this.add(doc);
    }, this);
  });

  docs.forEach(function (doc) {
    docMap.set(doc.title, doc.url);
  });
}

// The onkeypress handler for search functionality
function searchOnKeyDown(e) {
  const keyCode = e.keyCode;
  const parent = e.target.parentElement;
  const isSearchBar = e.target.id === "search-bar";
  const isSearchResult = parent ? parent.id.startsWith("result-") : false;
  const isSearchBarOrResult = isSearchBar || isSearchResult;

  if (keyCode === 40 && isSearchBarOrResult) {
    // On 'down', try to navigate down the search results
    e.preventDefault();
    e.stopPropagation();
    selectDown(e);
  } else if (keyCode === 38 && isSearchBarOrResult) {
    // On 'up', try to navigate up the search results
    e.preventDefault();
    e.stopPropagation();
    selectUp(e);
  } else if (keyCode === 27 && isSearchBarOrResult) {
    // On 'ESC', close the search dropdown
    e.preventDefault();
    e.stopPropagation();
    closeDropdownSearch(e);
  }
}

// Search is only done on key-up so that the search terms are properly propagated
function searchOnKeyUp(e) {
  // Filter out up, down, esc keys
  const keyCode = e.keyCode;
  const cannotBe = [40, 38, 27];
  const isSearchBar = e.target.id === "search-bar";
  const keyIsNotWrong = !cannotBe.includes(keyCode);
  if (isSearchBar && keyIsNotWrong) {
    // Try to run a search
    runSearch(e);
  }
}

// Move the cursor up the search list
function selectUp(e) {
  if (e.target.parentElement.id.startsWith("result-")) {
    const index = parseInt(e.target.parentElement.id.substring(7));
    if (!isNaN(index) && (index > 0)) {
      const nextIndexStr = "result-" + (index - 1);
      const querySel = "li[id$='" + nextIndexStr + "'";
      const nextResult = document.querySelector(querySel);
      if (nextResult) {
        nextResult.firstChild.focus();
      }
    }
  }
}

// Move the cursor down the search list
function selectDown(e) {
  if (e.target.id === "search-bar") {
    const firstResult = document.querySelector("li[id$='result-0']");
    if (firstResult) {
      firstResult.firstChild.focus();
    }
  } else if (e.target.parentElement.id.startsWith("result-")) {
    const index = parseInt(e.target.parentElement.id.substring(7));
    if (!isNaN(index)) {
      const nextIndexStr = "result-" + (index + 1);
      const querySel = "li[id$='" + nextIndexStr + "'";
      const nextResult = document.querySelector(querySel);
      if (nextResult) {
        nextResult.firstChild.focus();
      }
    }
  }
}

// Search for whatever the user has typed so far
function runSearch(e) {
  if (e.target.value === "") {
    // On empty string, remove all search results
    // Otherwise this may show all results as everything is a "match"
    applySearchResults([]);
  } else {
    const tokens = e.target.value.split(" ");
    const moddedTokens = tokens.map(function (token) {
      // "*" + token + "*"
      return token;
    })
    const searchTerm = moddedTokens.join(" ");
    const searchResults = idx.search(searchTerm);
    const mapResults = searchResults.map(function (result) {
      const resultUrl = docMap.get(result.ref);
      return { name: result.ref, url: resultUrl };
    })

    applySearchResults(mapResults);
  }

}

// After a search, modify the search dropdown to contain the search results
function applySearchResults(results) {
  const dropdown = document.querySelector("div[id$='search-dropdown'] > .dropdown-content.show");
  if (dropdown) {
    //Remove each child
    while (dropdown.firstChild) {
      dropdown.removeChild(dropdown.firstChild);
    }

    //Add each result as an element in the list
    results.forEach(function (result, i) {
      const elem = document.createElement("li");
      elem.setAttribute("class", "dropdown-item");
      elem.setAttribute("id", "result-" + i);

      const elemLink = document.createElement("a");
      elemLink.setAttribute("title", result.name);
      elemLink.setAttribute("href", result.url);
      elemLink.setAttribute("class", "dropdown-item-link");

      const elemLinkText = document.createElement("span");
      elemLinkText.setAttribute("class", "dropdown-item-link-text");
      elemLinkText.innerHTML = result.name;

      elemLink.appendChild(elemLinkText);
      elem.appendChild(elemLink);
      dropdown.appendChild(elem);
    });
  }
}

// Close the dropdown if the user clicks (only) outside of it
function closeDropdownSearch(e) {
  // Check if where we're clicking is the search dropdown
  if (e.target.id !== "search-bar") {
    const dropdown = document.querySelector("div[id$='search-dropdown'] > .dropdown-content.show");
    if (dropdown) {
      dropdown.classList.remove("show");
      document.documentElement.removeEventListener("click", closeDropdownSearch);
    }
  }
}
